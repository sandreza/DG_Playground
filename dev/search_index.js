var documenterSearchIndex = {"docs":
[{"location":"dg_methods/#Discontinuous-Galerkin","page":"Home","title":"Discontinuous Galerkin","text":"","category":"section"},{"location":"dg_methods/","page":"Home","title":"Home","text":"In CLIMA the Discontinuous Galerkin method serves as our spatial discretization method. It may be thought of as a combination of spectral methods and finite volume methods. The method is a higher-order generalization of a finite volume method.","category":"page"},{"location":"dg_methods/","page":"Home","title":"Home","text":"This section contains the following review of Discontinuous Galerkin methods","category":"page"},{"location":"dg_methods/","page":"Home","title":"Home","text":"Single Element\nBoundary Conditions\nVariational Crimes","category":"page"},{"location":"physics/#Physics","page":"Home","title":"Physics","text":"","category":"section"},{"location":"physics/","page":"Home","title":"Home","text":"The operators in CLIMA come from various physical scenarios that we model with a simplified set of equations. The models that we will discuss here are typically motivated by various forms of turbulence closures or parameterizations.","category":"page"},{"location":"dg_single_element/#sec:single_element","page":"Single Element","title":"Single Element","text":"","category":"section"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"Our goal will be to understand the Discontinuous Galerkin (DG) discretization for a single element.  We will use this to illustrate the role of boundary fluxes but also to understand differences with finite volume codes. To better illustrate the discrete implementation of the weak formulation of the conservation equation, we consider the advection-diffusion equation","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    partial_t rho + partial_x left( u rho right) = partial_x sigma\n    \n    sigma = partial_x rho\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"where u in mathbbR, the domain is x in (-1  1) equiv E, and rho(xt) and/or sigma(xt) satisfies some prescribed boundary conditions. The boundary of the domain is denoted by  -1 1 equiv partial E. We will use the following abbreviations for integrals","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    int_E f equiv int_x = -1^x = 1 f(x) dx\n    text and  text \n    int_partial E f equiv f(1) - f(-1)\nendaligned","category":"page"},{"location":"dg_single_element/#Weak-Form","page":"Single Element","title":"Weak Form","text":"","category":"section"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"The weak form of the equations is obtained by multiplying through each equation by test functions psi(x) , varphi(x), integrating over the domain, and integrating by parts on the terms with derivatives, to obtain","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    partial_t int_E psi rho - int_E  (partial_x psi) (u rho) =\n    - int_E (partial_x psi) sigma\n    + int_partial E psi sigma - int_partial E  psi (u rho)\n    \n    int_E varphi sigma = - int_E (partial_x varphi) rho + int_partial E  varphi rho\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"The terms on the boundary are interpreted as numerical fluxes, typically denoted by an asterisk as follows","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    partial_t int_E psi rho - int_E  (partial_x psi) (u rho) =\n    - int_E (partial_x psi) sigma\n    + int_partial E psi sigma^* - int_partial E  psi (u rho)^*\n    \n    int_E varphi sigma = - int_E (partial_x varphi) rho + int_partial E  varphi rho^*\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"This form is taken as the definition of our partial differential equation in weak form.","category":"page"},{"location":"dg_single_element/#Discontinuous-Galerkin-Approximation","page":"Single Element","title":"Discontinuous Galerkin Approximation","text":"","category":"section"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"In DG we approximate the spatial structure of our functions rho(xt) and sigma(xt) by a set of linearly independent polynomials, ell_i(x) for i = 0  N, within each element, so that","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    rho(xt) = rho_i(t) ell_i(x) text and  sigma(xt) = sigma_i(t) ell_i(x)\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"where we are using Einstein summation convention for repeated indices. To reduce notational clutter we will occasionally suppress the x-dependence and t-dependence in the following manner","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    rho = rho_i ell_i text and  sigma = sigma_i ell_i\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"We have 2(N+1) degrees of freedom (N+1 for rho_i and N+1 for sigma_i), thus we must specify 2(N+1) test functions for which we are satisfying the equation. In the Galerkin method we take the test functions to be the same as the basis in which we are representing our solution, i.e., psi = ell_i(x) for i = 0 N and varphi = ell_j(x) for j = 0   N.","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"In index notation and with Einstein summation convection, equations become (basically just replacing psi = varphi = ell_i and rho = rho_j ell_j and sigma = sigma_j ell_j)","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    partial_t int_E ell_i ell_j rho_j - int_E  ell_i ell_j (u rho_j) =\n    - int_E ell_i ell_j sigma_j\n    + int_partial E ell_i sigma^* - int_partial E  ell_i  (u rho)^*\n    \n    int_E ell_i ell_j sigma_j = - int_E ell_i ell_j rho_j + int_partial E  ell_i rho^*\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"where we have introduced the prime notation to denote a derivative, e.g., ell_i denotes the derivative of ell_i. We see that a few operators come up over and over again, and they are given special names. The operator whose entries are given by","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalM_ij = int_E ell_i ell_j\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"is known as the mass matrix, a name borrowed from the finite element community. The operator whose entries are given by","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalS_ji = int_E ell_i ell_j\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"is known as the stiffness matrix a name also borrowed from the finite element community. The flipping of the indices on the entries of mathcalS is purposeful and corresponds to how it is \"usually\" defined.","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"The boundary operators become","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    int_partial E  ell_i rho^* = ell_i(1) rho^*(1) - ell_i(-1) rho^*(-1)\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"and similarly for the other terms. We are abbreviating rho^*(x = 1 t) as rho^*(1) and we will do so for other variables as well. The boundary terms play a pivotal role in how one formulates boundary conditions as well as how one couples multiple elements together.","category":"page"},{"location":"dg_single_element/#Discrete-Equations","page":"Single Element","title":"Discrete Equations","text":"","category":"section"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"Once we make choices for our functions ell_i(x) we can write a set of discrete equations that represent the Discontinuous Galerkin scheme. We choose the ell_i to be Lagrange interpolants of a set of nodal points x_j for j = 0  N.  Being a Lagrange interpolant, by definition, means that ell_i(x_j) = delta_ij where delta_ij is the Kronecker delta. The nodal points x_j are chosen as the extrema of Jacobi polynomials. These points are able to be efficiently calculated with either explicit formulas (as is the case with Chebyshev polynomials where x_j = cos(pi j  N) for j = 0  N) or by solving certain eigenvalue problems, as is the case for Legendre polynomials.","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"Regardless of the exact form, it is always the case that the endpoints are 1 and -1 for polynomial orders bigger than one. We will use the convention that x_0 = -1 and x_N = 1 here, but with Chebyshev extrema one usually takes the opposite ordering. For polynomial order zero we take x_0 = 0 and ell_0 = 1 in order to reduce back to a finite volume scheme. With this convention and the definition of our Lagrange interpolants, we have ell_i(-1) = delta_iN and ell_i(1) = delta_i0.","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"With notation and conventions now established, the discrete equations are","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    partial_t mathcalM_ij rho_j - mathcalS_ji (u rho_j) =\n    - mathcalS_ji sigma_j\n    + delta_iN sigma^*(1)\n    - delta_i0 sigma^*(-1)\n    - delta_iN (u rho)^*(1)\n    +\n    delta_i0 (u rho)^*(-1)\n    \n    mathcalM_ij sigma_j = -  mathcalS_jirho_j\n    + delta_iN rho^*(1)\n    -\n    delta_i0 rho^*(-1)\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"We will explicitly calculate the mass and stiffness matrices in the following subsections.","category":"page"},{"location":"dg_single_element/#Explicit-representations","page":"Single Element","title":"Explicit representations","text":"","category":"section"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"For polynomial order zero we can work out all the Lagrange interpolants, extrema points, mass matrices, and stiffness matrices, by hand easily. Firstly, note that the extrema points for polynomial order N=0 is x_0 = 0. Note that here we have x_0 = x_N since N = 0. The Lagrange interpolants are","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    ell_0(x) = 1\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"The mass and stiffness matrices are","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalM_00 = 2 text and  mathcalS_00 = 0\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"Thus, polynomial order zero is equivalent to a finite volume scheme.","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"For polynomial order one we can work out all the Lagrange interpolants, extrema points, mass matrices, and stiffness matrices, by hand without too much effort. Firstly, note that the extrema points for polynomial order N=1 is x_0 = -1 and x_1 = 1. The Lagrange interpolants are","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    ell_0(x) = fracx - 1-2 text and  ell_1(x) = fracx + 12\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"To calculate the entries of the mass matrix, one needs to calculate","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalM_ij = int_E ell_i ell_j\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"i.e.","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalM_00 = int_-1^1 left(fracx - 1-2right)^2 dx = 23\n    text  text and  text \n    mathcalM_01 = int_-1^1 fracx^2 - 1-4 dx = 13 \nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"By symmetry mathcalM_00 = mathcalM_11 and mathcalM_01 = mathcalM_10 so","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalM =\n    frac13beginbmatrix\n    2  1 \n    1  2\n    endbmatrix\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"The stiffness matrix is obtained similarly, we must calculate the entries","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalS_ji = int_E ell_i ell_j\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"so","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalS^T_00  = int_-1^1 frac-12left(fracx + 12 right) dx = -12\n    text text  text \n    mathcalS^T_01  = int_-1^1 frac-12left(fracx - 1-2 right) dx = -12\n    \n    mathcalS^T_10  = int_-1^1 frac12left(fracx - 1-2 right) dx = 12\n    text text  text \n    mathcalS^T_11  = int_-1^1 frac12left(fracx + 12 right) dx = 12\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"so that","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalS^T = frac12 beginbmatrix\n        -1  -1 \n        1  1\n    endbmatrix\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"Unlike polynomial order zero and finite volume schemes, all non-zero polynomial order DG discretizations have a non-zero stiffness matrix. Non-zero stiffness matrices play an important role in the determining the stability of the numerical discretization and adds extra complications that do not present themselves in the finite volume case.","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"Luckily this has been automated for any polynomial order, so we just display the results polynomial order two here. The extrema points are x_0 = -1, x_1 = 0, x_2 = 1. The Lagrange interpolants are","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    ell_0(x) = x(x-1)2\n    text  \n    ell_1(x) = -(x+1)(x-1)\n    text  and \n    ell_2(x) = x(x+1)  2\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"The mass and stiffness matrices are","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalM = frac115\n    beginbmatrix\n      4   2  -1 \n  2   16    2 \n -1   2   4\n    endbmatrix\n    text and \n    mathcalS^T =\n    frac16\n    beginbmatrix\n -3   -4   1 \n  4   0   -4 \n -1   4   3 \n    endbmatrix\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"In DG_Playground we can extract these matrices as follows","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"using DG_Playground\nN = 2;\nα = β = 0.0;\nr = jacobiGL(α, β, N);\nD = dmatrix(r, α, β, N);\nV = vandermonde(r, α, β, N);\nMi = V * V';\nM = inv(Mi)\nSᵀ  = (M * D)'","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"where N is the polynomial order, M is the mass matrix and S^T is the transpose of the stiffness matrix, and alpha and beta are exactly as in Jacobi Polynomials.","category":"page"},{"location":"dg_single_element/#Algebraic-Properties-of-Operators","page":"Single Element","title":"Algebraic Properties of Operators","text":"","category":"section"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"We have seen some properties in the previous sections that are particular realizations of more algebraic properties of DG operators. Here we will collect a few such algebraic properties.","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"The first is that","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    int_E rho^2 = rho_i mathcalM_ij rho_j\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"The proof is a one liner since rho = rho_i ell_i and int_E  (ell_i ell_j ) = mathcalM_ij. The calculation is as follows","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n  int_E rho^2  = int_E (rho_i ell_i) (rho_j ell_j ) =  rho_i int_E  (ell_i ell_j ) rho_j = rho_i mathcalM_ij rho_j\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"Furthermore, observe that that the mass matrix is symmetric, i.e., mathcalM_ij = mathcalM_ji.","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"The next property is the discrete integration by parts formula","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalS_ji + mathcalS_ij = delta_iNdelta_jN - delta_i0delta_j0\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"This follows from","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n   mathcalS_ji + mathcalS_ij = int_E ell_i ell_j + int_E ell_j ell_i = int_partial E  ell_j ell_i = ell_j(1) ell_i(1) - ell_j(-1) ell_i(-1)\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"via integration by parts, the definition of the Lagrange interpolant, and our convention that ell_i(1) = delta_iN and ell_i(-1) = delta_i0.","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"This last algebraic property follows from the previous","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    rho_i mathcalS_ji rho_j = frac12 left (rho_N)^2 - (rho_0)^2 right\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"To see this write","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"beginaligned\n    mathcalS_ji = frac12left(mathcalS_ji + mathcalS_ij right) + frac12left(mathcalS_ji - mathcalS_ij right)\nendaligned","category":"page"},{"location":"dg_single_element/","page":"Single Element","title":"Single Element","text":"and use the fact that the anti-symmetric component vanishes rho_ileft(mathcalS_ji - mathcalS_ij right) rho_j = 0","category":"page"},{"location":"inexact_quadrature/#sec:variational_crimes","page":"Variational Crimes","title":"Variational Crimes","text":"","category":"section"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"We will use the same notation as Single Element. The other thing that makes DG different from finite volume is aliasing issues. Consider Burgers' equation, which is the nonlinear PDE","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    partial_t rho + partial_x f = 0 \n    f = rho^2\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"In the Discontinuous Galerkin method all quantities are interpreted as belong to the polynomial basis set, including the flux term f, i.e., we represent our functions as","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    rho = rho_i ell_i text and \n    f = f_i ell_i \nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"which are polynomials of degree N, for i = 0  N. But yet f involves a \\textit{product} of two polynomials of degree N, which is a polynomial of degree 2N. This is not an issue in finite volume codes where N = 0 so that 2N = 0, but can sometimes lead to issues in Discontinuous Galerkin codes. This is the classic closure problem but in the context of numerical methods.","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"Thus we must define in what sense we are representing a polynomial of degree 2N by a polynomial of degree N. We will discuss four (non-exhaustive) options","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"Exact quadrature version 1\nExact quadrature version 2\nIgnoring higher order terms, (Polynomials of Degree N+1 and higher)\nMultiplying nodal points together","category":"page"},{"location":"inexact_quadrature/#Exact-quadrature-version-1","page":"Variational Crimes","title":"Exact quadrature version 1","text":"","category":"section"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"For exact quadrature we satisfy the nonlinear flux relation in the same sense that we are satisfying the PDE. We multiply through by test functions psi and integrate,","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n   int_Omega psi f = int_Omega psi rho^2\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"We represent functions as f = f_j ell_j and rho_j ell_j so that the equation becomes","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    int_Omega psi f_j ell_j = int_Omega psi rho_j ell_j rho_k ell_k\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"We the take our test function space to be the same as our basis function space psi = ell_i to get","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n     int_Omega ell_i  ell_j f_j = int_Omega ell_i  ell_j  ell_k rho_j rho_k\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"The first term is just the entries of the mass matrix, i.e.,","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n  mathcalM_ij  =  int_Omega ell_i  ell_j \nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"But for quadratic nonlinearities we need to compute integrals like","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n   mathcalQ^1_ijk equiv int_Omega ell_i(x) ell_j(x) ell_k(x)\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"which is a new object mathcalQ^1. Thus we represent the equation as follows","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    partial_t mathcalM_ij rho_j - mathcalS_ji f_j = delta_0i f^*(x=-1t) - delta_Ni f^*(x=1t)\n    \n    mathcalM_ij f_j = mathcalQ_ijk^1 rho_j rho_k\nendaligned","category":"page"},{"location":"inexact_quadrature/#Exact-quadrature-version-2","page":"Variational Crimes","title":"Exact quadrature version 2","text":"","category":"section"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"This is similar to the previous one, except we directly represent the derivative term","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n   mathcalQ^2_ijk equiv int_Omega ell_i(x) ell_j(x) ell_k(x)\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"so that the discrete equations are","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    partial_t mathcalM_ij rho_j - mathcalQ^2_ijk rho_j rho_k = delta_0i f^*(x=-1t) - delta_Ni f^*(x=1t)\nendaligned","category":"page"},{"location":"inexact_quadrature/#Ignoring-higher-order-terms","page":"Variational Crimes","title":"Ignoring higher order terms","text":"","category":"section"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"We carry through the multiplication of the polynomials, but just chop off all the terms corresponding to higher order terms. This can be done by ignoring higher Legendre modes (which is consistent with \"Exact Quadrature version 1\") or by ignoring the monomial terms (which is not consistent with \"Exact Quadrature version 1\").","category":"page"},{"location":"inexact_quadrature/#Multiplying-nodal-points-together","page":"Variational Crimes","title":"Multiplying nodal points together","text":"","category":"section"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"One perspective is that we are satisfying the equation","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    f_i ell_i = (rho_i ell_i) (rho_j ell_j)\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"exactly at the nodal points. This leads to f_j = (rho_j)^2. If we do so the we are mixing discretizations. Another perspective is that we approximate \"exact quadrature version 1\",  as","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n   mathcalQ_1_ijk equiv int_Omega ell_i(x) ell_j(x) ell_k(x) approx mathcalM_ij delta_jk\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"so that f_j = (rho_j)^2. This is also known as inexact quadrature or a variational crime. This approximation can lead to instability issues which are ameliorated either through dissipation, increasing resolution, or filters. When things are very resolved the higher order polynomial terms don't really play a role. This can either occur due h-refinement, since things are locally linear, or p-refinement for more complex reasons. The reasons are analogous to what happens with Fourier modes of analytic functions. Higher Fourier modes don't really matter since they decay exponentially and become negligible.","category":"page"},{"location":"inexact_quadrature/#Explicit-Example","page":"Variational Crimes","title":"Explicit Example","text":"","category":"section"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"We now go through an explicit example of the differences for linear elements / polynomial order 1. Here the Lagrange interpolants are","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    ell_0(x) = (x-1) (-2) text and  ell_1(x) = (x+1)  2\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"We can perform all integrals from the previous section","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    mathcalQ^1_000 = mathcalQ^1_111 =  12 \n    mathcalQ^1_011 = mathcalQ^1_101 = mathcalQ^1_110 = 16\n    \n    mathcalQ^1_100 =\n    mathcalQ^1_010 =\n    mathcalQ^1_001 = 16\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"so that","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    beginbmatrix\n    23  13 \n    13  23\n    endbmatrix\n    beginbmatrix\n    f_0 \n    f_1\n    endbmatrix\n    =\n        beginbmatrix\n    12  13  16 \n    16  13  12\n    endbmatrix\n        beginbmatrix\n    (rho_0)^2 \n    rho_0 rho_1 \n    (rho_1)^2\n    endbmatrix\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"which is","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n        beginbmatrix\n    f_0 \n    f_1\n    endbmatrix\n    =\n        beginbmatrix\n    56  13  -16 \n    -16  13  56\n    endbmatrix\n        beginbmatrix\n    (rho_0)^2 \n    rho_0 rho_1 \n    (rho_1)^2\n    endbmatrix\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"For the other operator we have","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    mathcalQ^2_000 = mathcalQ_2_011 = -13\n    \n    mathcalQ^2_010 = mathcalQ^2_001 = -16\n    \n    mathcalQ^2_1ij = -mathcalQ_2_0ij  \nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"Note that mathcalS_jimathcalQ^1_jks = mathcalQ^2_iks. The two ``exact quadrature\" versions coincide for linear elements.","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"Now let us check to see what it means to lop off higher  order terms","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    4 rho^2 = 4 left(rho_0 fracx-1-2 + rho_1 fracx+12 right)^2\n    \n    = (rho_0^2 + rho_1^2 - 2 rho_0 rho_1) x^2\n    + 2(rho_0^2 - rho_1^2)x + (rho_0^2 + rho_1^2 + 2 rho_0 rho_1)\n    \n    = (rho_0 - rho_1)^2 x^2\n    + (3 rho_0^2 - rho_1^2 + 2rho_0 rho_1 )fracx-1-2 + (3 rho_1^2 - rho_0^2 + 2 rho_0 rho_1)fracx+12\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"In this case we just neglect the term in front of x^2. Thus f becomes","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n        beginbmatrix\n    f_0 \n    f_1\n    endbmatrix\n    =\n        beginbmatrix\n    34  12  -14 \n    -14  12  34\n    endbmatrix\n        beginbmatrix\n    (rho_0)^2 \n    rho_0 rho_1 \n    (rho_1)^2\n    endbmatrix\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"If we had instead decided to take off the highest Legendre modes (as opposed to highest polynomial order), then we should reduce back to the exact quadrature formula (version 1). To see this first note that the first few legendre polynomials are","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    P_0(x) = 1 text   P_1(x) = x  text   and  P_2(x) = frac32 left(x^2 - frac13 right)\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"Thus if we rewrite expressions with the highest polynomial order instead represented instead as Legendre modes via x^2 = x^2 - 13 + 13 = 23 P_2(x) + 13, then we get","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n    4 rho^2 =\n    (rho_0 - rho_1)^2 (x^2-13+13)\n    \n    + (3 rho_0^2 - rho_1^2 + 2rho_0 rho_1 )fracx-1-2 + (3 rho_1^2 - rho_0^2 + 2 rho_0 rho_1)fracx+12\n    \n    = (rho_0 - rho_1)^2 frac23 P_2(x)\n    \n    + left(frac103 rho_0^2 - frac23rho_1^2 + frac43 rho_0 rho_1 right)fracx-1-2 + left(frac103 rho_1^2 - frac23 rho_0^2 + frac43 rho_0 rho_1  right)fracx+12\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"Neglecting the higher order Legendre modes (in this case just P_2(x), but in general much more). We indeed get (upon dividing by 4)","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n        beginbmatrix\n    f_0 \n    f_1\n    endbmatrix\n    =\n        beginbmatrix\n    56  13  -16 \n    -16  13  56\n    endbmatrix\n        beginbmatrix\n    (rho_0)^2 \n    rho_0 rho_1 \n    (rho_1)^2\n    endbmatrix\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"as before.","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"And the last option is to represent f_0 and f_1 as","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"beginaligned\n        beginbmatrix\n    f_0 \n    f_1\n    endbmatrix\n    =\n        beginbmatrix\n    1  0  0 \n    0  0  1\n    endbmatrix\n        beginbmatrix\n    (rho_0)^2 \n    rho_0 rho_1 \n    (rho_1)^2\n    endbmatrix\nendaligned","category":"page"},{"location":"inexact_quadrature/","page":"Variational Crimes","title":"Variational Crimes","text":"Again this just corresponds to multiplying things nodally, point by point. This option leads to code that is easy to write and is computationally cheap compared to the rest of the methods.","category":"page"},{"location":"convective_adjustment/#Convective-Adjustment","page":"Convective Adjustment","title":"Convective Adjustment","text":"","category":"section"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"Convective adjustment is a simple parameterization that attempts the capture the effect of mixing due to convection. Physically this occurs because dense water parcels tend to sink and and light water parcels tend to rise.","category":"page"},{"location":"convective_adjustment/#Mathematical-Form","page":"Convective Adjustment","title":"Mathematical Form","text":"","category":"section"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"Typically the effect of convective adjustment is captured via a nonlinear diffusivity such as","category":"page"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"beginaligned\nkappa(rho) = begincases\nkappa_1  text if text   partial_z rho  0\n\nkappa_2  text otherwise\nendcases\nendaligned","category":"page"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"where kappa_1 gg kappa_2, and z is aligned with the direction of gravity. Thinking of $ \\rho $ as density, a simple parameterization of convection is of the form","category":"page"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"beginaligned\npartial_t rho = nabla cdot left kappa(rho) nabla rho right\nendaligned","category":"page"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"Intuitively, the above nonlinear diffusivity models the effect of mixing when heavy fluid parcels overlie light fluid parcels. Here the  mixing is modeled via diffusion with a large diffusivity constant. This is by no means the only way to model the effect of mixing, but it is a starting point.","category":"page"},{"location":"convective_adjustment/#Typical-Time-Discretization","page":"Convective Adjustment","title":"Typical Time-Discretization","text":"","category":"section"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"A typical time-discretization would be","category":"page"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"beginaligned\nrho^n+1 - Delta t partial_z left kappa(rho^n) partial_z rho^n+1 right = rho^n + Delta t left( f^n + nabla^H cdot left kappa(rho^n) nabla^H rho^n right right)\nendaligned","category":"page"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"where the forcing function f^n comes from boundary condition and we have split the gradient operator into the vertically aligned component z and the other (horizontal) directions. When discretized, the time-stepping method yields a Helmholtz-like problem that needs to be solved every timestep. The reason why it is not exactly a Helmholtz-like problem is due to the use of inexact quadrature for variable diffusivity. In this context, inexact quadrature means that, instead of projecting nonlinear terms onto the appropriate basis, we multiply them together at the collocation points.","category":"page"},{"location":"convective_adjustment/#Simplification","page":"Convective Adjustment","title":"Simplification","text":"","category":"section"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"There are a wide variety of functional forms that kappa(rho^n) can take on, but typically it is similar to","category":"page"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"beginaligned\n    kappa(rho^n) approx\n    begincases\n    kappa_1  text if  z  h \n    kappa_2  text if  z leq h\n    endcases\nendaligned","category":"page"},{"location":"convective_adjustment/","page":"Convective Adjustment","title":"Convective Adjustment","text":"where z in 0 L and h can take on all values between 0 L and varies depending on the horizontal components. The reason why there is usually just one place that kappa changes values of diffusivity has to do with typical physical scenarios that arise in the ocean / atmosphere. The ocean interior is stably stratified. Cooling comes from the surface of the ocean and leads to mixing that starts in the upper ocean and progresses towards the ocean abyss. The solution to linear systems of this form (when Delta t becomes large), is essentially constant in the region of high diffusivity.","category":"page"},{"location":"function_index/#List-of-functions-in-DG_Playground-module","page":"Function Index","title":"List of functions in DG_Playground module","text":"","category":"section"},{"location":"function_index/","page":"Function Index","title":"Function Index","text":"Modules = [DG_Playground]","category":"page"},{"location":"function_index/#DG_Playground.Field1D","page":"Function Index","title":"DG_Playground.Field1D","text":"Field1D(mesh)\n\nDescription\n\ninitialize Field1D struct\n\nArguments\n\nmesh: a mesh to compute on\n\nReturn Values:\n\nu : the field to be computed\nu̇: numerical solutions for the field\nflux: the numerical flux for the computation\n\n\n\n\n\n","category":"type"},{"location":"function_index/#DG_Playground.Mesh-NTuple{4,Any}","page":"Function Index","title":"DG_Playground.Mesh","text":"mesh(K, n, xmin, xmax)\n\nDescription\n\nouter_constructor mesh struct\n\nArguments\n\nK: number of elements\nn: polynomial order\nxmin: lower bound\nxmax: upper bound\n\nReturn Values: x\n\nreturn grid values\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.external_params","page":"Function Index","title":"DG_Playground.external_params","text":"external_params{T,S}\n\nDescription\n\nstruct for external params needed for advection\n\nMembers\n\nfirst is velocity\nsecond is value for α\n\n\n\n\n\n","category":"type"},{"location":"function_index/#DG_Playground.build_operator-Tuple{Any,Mesh}","page":"Function Index","title":"DG_Playground.build_operator","text":"buildoperator(affineoperator!, 𝒢::Mesh; mass_matrix = false)\n\nDescription\n\nbuilds affine operator associated with DG operator\n\nComment\n\nWith non-homogenous boundary conditions becomes affine\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.buildmaps1D-NTuple{8,Any}","page":"Function Index","title":"DG_Playground.buildmaps1D","text":"buildmaps1D(K, nGL, nFP, nFaces, fmask, EtoE, EtoF, x)\n\nDescription\n\nconnectivity matrices for element to elements and elements to face\n\nArguments\n\nK: number of elements\nnGL: number of points within an element (polynomial degree + 1)\nnFP: 1\nnFaces: 2\nfmask: an element by element mask to extract edge values\nEtoE: element to element connectivity\nEtoF: element to face connectivity\nx: Guass lobatto points\n\nReturn Values: vmapM, vmapP, vmapB, mapB, mapI, mapO, vmapI, vmapO\n\nvmapM: vertex indices, (used for interior u values)\nvmapP: vertex indices, (used for exterior u values)\nvmapB: vertex indices, corresponding to boundaries\nmapB: use to extract vmapB from vmapM\nmapI: Index of left boundary condition\nmapO: Index of right boundary condition\n\nExample | uses ../utils.jl\n\nK = 3 n = 3; α = 0; β = 0; xmin = 0; xmax = 2π; nGL = n + 1 nFP = 1 nFaces = 2\n\nr = jacobiGL(α, β, n)\n\nVX, EtoV = unimesh1D(xmin, xmax, K) EtoE, EtoF = connect1D(EtoV) x = gridvalues1D(VX, EtoV, r) fx = edgevalues1D(r,x)\n\nvmapM, vmapP, vmapB, mapB, mapI, mapO, vmapI, vmapO = buildmaps1D(K, nGL, nFP, nFaces, fmask, EtoE, EtoF, x)\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.connect1D-Tuple{Any}","page":"Function Index","title":"DG_Playground.connect1D","text":"connect1D(EtoV)\n\nDescription\n\nbuilds global connectivity arrays for 1D\n\nArguments\n\nEtoV: element to node connectivity | a Matrix of size Kx2\n\nReturn Values: EtoE, EtoF\n\nEtoE: element to element connectivity\nEtoF: element to face connectivity\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.djacobi-Tuple{Any,Any,Any,Int64}","page":"Function Index","title":"DG_Playground.djacobi","text":"djacobi(x, α, β, n)\n\nDescription\n\nEvaluates the derivative of the jacobi polynomial at the point x\n\nArguments\n\nx: point at which you will evaluate the derivative of the jacobi polynomial\nα: first parameter for Jacobi polynomials\nβ: second parameter for Jacobi polynomials\nn : order\n\nReturn\n\ny: the derivative of the of the Jacobi polynomial\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.dmatrix-NTuple{4,Any}","page":"Function Index","title":"DG_Playground.dmatrix","text":"dmatrix(x, α, β, N)\n\nDescription\n\nReturn the differentiation matrix of order N at the values x\nAllocates too much memory\n\nArguments\n\nx: points at which to evaluate the Jacobi polynomials\nα: first parameter for Jacobi polynomials\nβ: second paramater for Jacobi polynomials\nN: maximum order of Jacobi polynomial to include\n\nReturn Values\n\nD: the differentiation matrix\n\nExample\n\nSee LegendreTests.jl\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.dropϵzeros!-Tuple{Any,Any}","page":"Function Index","title":"DG_Playground.dropϵzeros!","text":"dropϵzeros!(sparseMatrix, drop_criteria)\n\nDescription\n\nDrops machine zeros in sparse matrix\n\nArguments\n\nA: a sparse matrix\ndrop_criteria: criteria for dropping entries\n\nreturn\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.dropϵzeros!-Tuple{Any}","page":"Function Index","title":"DG_Playground.dropϵzeros!","text":"dropϵzeros!(sparseMatrix)\n\nDescription\n\nDrops machine zeros in sparse matrix\n\nArguments\n\n!A: a sparse matrix\n\nreturn\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.dvandermonde-NTuple{4,Any}","page":"Function Index","title":"DG_Playground.dvandermonde","text":"dvandermonde(x, α, β, N)\n\nDescription\n\nReturn the gradient of the vandermonde matrix of order N at the values x\nAllocates a little bit of memory\n\nArguments\n\nx: points at which to evaluate the Jacobi polynomials\nα: first parameter for Jacobi polynomials\nβ: second paramater for Jacobi polynomials\nN: maximum order of Jacobi polynomial to include\n\nReturn Values\n\nvr: gradient of vandermonde matrix\n\nExample\n\nSee LegendreTests.jl\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.edgevalues1D-Tuple{Any,Any}","page":"Function Index","title":"DG_Playground.edgevalues1D","text":"edgevalues1D(fmask, x)\n\nDescription\n\ncalculates edge values\n\nArguments\n\nfmask: face mask for GL edges\n\nx:  physical coordinates of solution on each element\n\nReturn Values: x\n\nfx: face values of x\n\nExample | ../utils.jl\n\nr = jacobiGL(0, 0, 4) x = gridvalues1D(VX, EtoV, r) fmask = fmask1D(r)[1] fx = edgevalues1D(fmask,x)\n\nthe locations of the edges in element 1 is fx[:, 1]\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.fmask1D-Tuple{Any}","page":"Function Index","title":"DG_Playground.fmask1D","text":"facemask1D(r)\n\nDescription\n\ncreates face mask\n\nArguments\n\nr: GL points\n\nReturn Values: x\n\nfmask1: standard facemask\nfmask2: alternate form\n\nExample | ../utils.jl\n\nr = jacobiGL(0, 0, 4) fmask = fmask1D(r)\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.geometric_factors-Tuple{Any,Any}","page":"Function Index","title":"DG_Playground.geometric_factors","text":"geometric_factors(x, Dʳ)\n\nDescription\n\ncomputes the geometric factors for local mappings of 1D elements\n\nArguments\n\nx: physical coordinates of solution for each element\n\nDʳ:\n\nReturn Values: rx, J\n\nrx: inverse jacobian\n\nJ: jacobian (in 1D a scalar)\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.gridvalues1D-Tuple{Any,Any,Any}","page":"Function Index","title":"DG_Playground.gridvalues1D","text":"gridvalues1D(xmin, xmax, K)\n\nDescription\n\nGenerates physical gridpoints with each element\n\nArguments\n\nVX: vertex values | an Array of size K+1\n\nEtoV: element to node connectivity | a Matrix of size Kx2\n\nr: LGL nodes in reference element | an array\n\nReturn Values: x\n\nx: physical coordinates of solution\n\nExample (uses ../utils.jl as well)\n\nxmin = 0 xmax = 2π K = 4\n\ncall functions\n\nVX, EtoV = unimesh1D(xmin, xmax, K) r = jacobiGL(0, 0, 4) x = gridvalues1D(VX, EtoV, r)\n\nx[:,1] is the physical coordinates within the first element\n\nfor plotting\n\nf(x) = sin(x) plot(x, f.(x))\n\nscatter(x,f.(x)) tends to work better\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.jacobi-Tuple{Any,Any,Any,Int64}","page":"Function Index","title":"DG_Playground.jacobi","text":"jacobi(x, α, β, n)\n\nDescription\n\nEvaluates the jacobi polynomial at the point x\n\nArguments\n\nx: point at which you will evaluate the jacobi polynomial\nα: first parameter for Jacobi polynomials\nβ: second parameter for Jacobi polynomials\nn : order\n\nReturn\n\ny: the value of the of the Jacobi polynomial\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.jacobiGL-Tuple{Any,Any,Any}","page":"Function Index","title":"DG_Playground.jacobiGL","text":"jacobiGL(α, β, N)\n\nDescription\n\nGuass Labatto quadrature points for the Jacobi Polynomial (α,β)\nThe quadrature weights are computed as well (but not returned)\n\nArguments\n\nα, β: Jacobi polynomial descriptors\nN:    order of quadrature\n\nReturn: x\n\nx: quadrature points  | array of size N+1\n\nExamples\n\njulia> x = jacobiGL(0, 0, 4)\n5-element Array{Float64,1}:\n -1.0\n -0.6546536707079759\n  4.440892098500626e-16\n  0.6546536707079771\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.jacobiGQ-Tuple{Any,Any,Any}","page":"Function Index","title":"DG_Playground.jacobiGQ","text":"jacobiGQ(α, β, N)\n\nDescription\n\nGuass Quadrature points and weights for the Jacobi Polynomial (α,β)\n\nInput\n\nα, β: Jacobi polynomial descriptors N:    order of quadrature points\n\nReturn: x,w\n\nx: quadrature points | array of size N+1 w: quadrature weights | array of size N+1 #Example α = 0 β = 0 N = 4 x, w = jacobiGQ(α, β, N)\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.lift1D-Tuple{Any}","page":"Function Index","title":"DG_Playground.lift1D","text":"lift1D(V, y) for computing fluxes helps compute a surface integral of a quantity note that the parentheses are necessary to prevent too much multiplcation the E function takes the surface integrals are presents it with respect to the full space inside an element the entire operator represents how fluxes flow into the interior of an element\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.lift1D_v2-Tuple{Any}","page":"Function Index","title":"DG_Playground.lift1D_v2","text":"lift1D_v2(V, y) for computing fluxes nodal form helps compute a surface integral of a quantity note that the parantheses are necessary to prevent too much multiplcation the E function takes the surface integrals are presents it with respect to the full space inside an element the entire operator represents how fluxes flow into the interior of an element\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.make_periodic1D!-Tuple{Any,Any}","page":"Function Index","title":"DG_Playground.make_periodic1D!","text":"make_periodic1D!(vmapP, u)\n\nDescription\n\nmakes the grid periodic by modifying vmapP.\nAssumes that the first node is connected to the last.\n\nArguments\n\nvmapP: exterior vertex map\nu: vertex vector\n\nReturn Values: none\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.normals1D-Tuple{Any}","page":"Function Index","title":"DG_Playground.normals1D","text":"normals1D(K)\n\nDescription\n\ncalculates face normals\n\nArguments\n\nK: number of elements\n\nReturn Values: normals\n\nnormals: face normals along each grid\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.unimesh1D-Tuple{Any,Any,Any}","page":"Function Index","title":"DG_Playground.unimesh1D","text":"unimesh1D(xmin, xmax, K)\n\nDescription\n\nGenerates a uniform 1D mesh\n\nArguments\n\nxmin: smallest value of array\nxmax: largest values of array\nK: number of elements in an array\n\nReturn Values: VX, EtoV\n\nVX: vertex values | an Array of size K+1\nEtoV: element to node connectivity | a Matrix of size Kx2\n\nExample\n\nxmin = -1 xmax =  1 K    =  4 VX, EtoV = unimesh1D(xmin, xmax, K)\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.vandermonde-NTuple{4,Any}","page":"Function Index","title":"DG_Playground.vandermonde","text":"vandermonde(x, α, β, N)\n\nDescription\n\nReturn vandermonde matrix of order N at the values x\nAllocates a little bit of memory\n\nArguments\n\nx: points at which to evaluate the Jacobi polynomials\nα: first parameter for Jacobi polynomials\nβ: second parameter for Jacobi polynomials\nN: maximum order of Jacobi polynomial to include\n\nReturn Values\n\nv: vandermonde matrix\n\nExample\n\nSee LegendreTests.jl\n\n\n\n\n\n","category":"method"},{"location":"boundary_conditions/#sec:se_bc","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"For the study of boundary conditions it suffices to consider a single element.","category":"page"},{"location":"boundary_conditions/#sec:advection_bc","page":"Boundary Conditions","title":"Boundary Conditions for the Advection Equation","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"First consider the case where we only have advection with wavespeed u so that the continuous equations are","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\npartial_t rho + partial_x (urho) = 0\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"and the discrete equations are","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    partial_t mathcalM_ij rho_j -  mathcalS_ji (u rho_j) =\n    - delta_iN (urho)^*(1)\n    +\n     delta_i0(urho)^*(-1)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"How do we enforce boundary conditions in this setting? We have only one spatial derivative, thus we must make a choice on which boundary to place boundary conditions. Since the wavespeed is positive, the flow of information is from left to right, hence it well posed to impose boundary conditions on the left end of the domain rho(x=-1 t), but not on the right endpoint rho(x = 1 t). (Information can't flow upstream.)","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Philosophically we can take a few viewpoints on enforcing a boundary conditions such as","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\nrho(x=-1 t) = rho_L\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"for some rho_L in mathbbR (here L stands for left). Mathematically we would like to determine the flux on the boundary","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    (urho)^*(-1t) = F( rho_0 rho_L)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"in a manner that is consistent with the boundary conditions. One option is to the think of the domain as extending beyond the left endpoint x  = -1 and rho having the value of rho_L from the left onwards. This is equivalent to introducing a ghost-point rho^+(-1t) = rho_L. The superscript + notation is typical for ghost-points or points exterior to our element. The points in the interior of the element are typically denoted with a superscript - such as rho^-. Our estimate of the flux can then be taken as an average of the flux calculated with the ghost point and and the flux calculated at the interior of our domain. This is known as a central boundary flux as is given by the formula","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n(urho)^*(-1) = fracurho^-(-1) + urho^+(-1)2\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"warning: Warning\nIt is not always the case that one uses a central flux on the boundary.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"One option is to choose the ghost point to be the value of the solution to the left of the domain, i.e., rho^+(-1) = rho_L, to get","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n(urho)^*(-1) = fracurho^-(-1) + urho^+(-1)2 = fracu rho_0 + u rho_L2\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"where we use a central flux to estimate the flux on the boundary. It is possible to use other types of fluxes, such as upwind or Rusanov.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Alternatively, we can state that we know what the flux should be on the boundary exactly, it should just be u rho_L, this leads to option 2","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n(urho)^*(-1) = u rho_L\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"In terms of our ghost point this mean that we selected rho^+(-1t) = - rho^-(-1t) + 2 rho_L, known as the reflection principle. This choice of ghost point essentially converts a central boundary flux into an inflow boundary flux.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Regardless of the exact choice of ghost-point, all of them must satisfy a consistency condition. If rho^+ = rho^- = textboundary condition, then the equation must be consistent. For example, the following ghost point is not consistent for all possible rho_L","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    rho^+(-1t) = - rho^-(-1t) +  rho_L\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"since","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    rho_L = - rho_L +  rho_L = 0\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"which is true for rho_L = 0, but not true for any other rho_L.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"We will address which of these ghost-point conditions to take shortly, but first let us discuss the right endpoint x = 1. What do we do for the right endpoint? After all we cannot impose any more boundary conditions, and yet we see that we still have this (urho^*)(1) dangling around. We cannot just set it equal to zero, since this is effectively just introducing another boundary condition, as well as being unphysical. The only option that we have is to leave it as a free endpoint given that we cannot impose anything. We do this through the use of a transmissive boundary flux, in this case","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    (u rho)^*(1) = u rho^-(x = 1) = u rho_N\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"In terms of our ghost point, this means that we take rho^+(1t) = rho^-(1t) = rho_N(t). This is how we let the boundary be \"free\". The endpoint \"just is what it is\".","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"After our brief detour on the right endpoint we are now ready to discuss the choice of fluxes on the left endpoint. In practice, to be perfectly frank, either are okay. The difference between the two boundary conditions is that one wiggles around the boundary condition (option 1) and the other enforces the boundary without wiggling around it (option 2), but both are stable with RK4. This freedom of choice, given to us by DG, is both dangerous and powerful. There are a few criteria that one can use to prune amongst all possible choices and they often revolve around either conservation arguments, physics, or energy arguments. Here \"energy\" does not mean kinetic or potential energy, but rather arguments that rely on Lyapunov functions to bound solutions to within some region in phase space. Often times quadratic Lyapunov functions are called energy.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Let us first look at the energy argument. For constant in time rho_L, it suffices to consider the energy argument with rho_L = 0 since we can just shift our solution rho rightarrow rho - rho_L without changing the underlying equation. The energy argument yields the following (just multiplying through by rho_i and utilizing the algebraic properties of the operators)","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    frac12 partial_t (rho_i mathcalM_ij rho_j) = rho_N left(fracu2rho_N - (u rho)^*(1) right) + rho_0 left( (u rho)^*(-1) - fracu2 rho_0 right)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Our choices of numerical fluxes yields","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    frac12 partial_t (rho_i mathcalM_ij rho_j)  = - fracu2rho_N^2  + fracu2 rho_0   rho_L\n    \n    =  - fracu2rho_N^2\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"for option 1 and","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    frac12 partial_t (rho_i mathcalM_ij rho_j)  = - fracu2rho_N^2  +  u rho_0 left( rho_L - frac12 rho_0 right)\n    \n    = -fracu2left(rho_N^2 + rho_0^2 right) + u rho_0 rho_L\n    \n    = -fracu2left(rho_N^2 + rho_0^2 right)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"for option 2. From this we can see that option 2 is the more stable one since it adds more dissipation. If instead we had made the choice rho^+(-1) = - alpha rho_0 + (1+alpha)rho_L, (where alpha = 1 corresponds to the second option and alpha = 0 corresponds to the first option) we would get","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    frac12 partial_t (rho_i mathcalM_ij rho_j) = - fracu2rho_N^2  +  u rho_0 left( frac1+alpha2rho_L - fracalpha2 rho_0 right)\n    \n    = -fracu2left(rho_N^2 + alpha rho_0^2 right) + u frac1+ alpha2 rho_0 rho_L\n    \n    = -fracu2left(rho_N^2 + alpha rho_0^2 right)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"which is okay most choices of alpha geq 0.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"In the original PDE we can go through the energy argument as well. Multiplying through by rho and integrating over the domain, we have (with rho(-1) = 0)","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\npartial_t frac12 int_E rho^2  = - fracu2 int_E partial_xleft( rho^2 right)\n= - fracu2 rho^2(1)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"This is somewhat suggestive of choosing alpha = 0. The reason why it is not exact is due to the fact that the discrete equations are different than the continuous ones, hence one cannot necessarily correspond the continuous rho(1) with the discrete rho_N. Furthermore, if we look at the discrete conservation property of rho, i.e. we integrate over the domain we get","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\npartial_t int_E rho = - u rho(1)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"on the PDE level and","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n partial_t  int_E rho  = (u rho)^*(-1) - (u rho)^*(1) = u (1-alpha)fracrho_02 - u rho_N\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"on the discretized level. The other equation is instead suggestive of choosing alpha = 1 to make the discrete approximation look like the continuous one.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"This just shows that sometimes imposing a particular kind of flux can place different principles at odds with one another. That is to say, using alpha = 1 respects the algebraic structure our conservation budget, but makes the discrete energy dissipation rate algebraically different, whereas alpha = 0 makes the discrete energy dissipation rate algebraically similar, but does not respect the conservation budget in the same way.","category":"page"},{"location":"boundary_conditions/#Boundary-Conditions-for-the-Diffusion-Equation","page":"Boundary Conditions","title":"Boundary Conditions for the Diffusion Equation","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Let us now consider the diffusion equation,","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    partial_t rho = partial_x sigma \n    sigma = partial_x rho\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"and its discrete form","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    partial_t mathcalM_ij rho_j =\n    - mathcalS_jisigma_j\n    + delta_iN sigma^*(1)\n    - delta_i0 sigma^*(-1)\n    \n    mathcalM_ij sigma_j = -  mathcalS_ji rho_j\n    + delta_iNrho^*(1)\n    -\n    delta_i0 rho^*(-1)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"To see how we enforce Dirichlet boundary conditions and Neumann Boundary conditions.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Let us first do Neumann boundary conditions. Because we are using a first-order formulation Neumann boundary conditions for rho means that we are imposing Dirichlet boundary conditions on sigma. Similar to the last section this means that the fluxes rho^*(1) and rho^*(-1) are free to be whatever they are on the boundary. Thus we choose transmissive boundary fluxes for rho^* , i.e.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    rho^*(1) = rho_N text and  rho^*(-1) = rho_0\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"For sigma we have to determine the numerical fluxes sigma^*(-1) and sigma^*(1), which will depend on sigma_0, sigma_N, as well as the boundary condition at the given endpoint. For this let us suppose that we want to enforce sigma(-1t) = sigma_L and sigma(1 t) = sigma_R. Then, just like in the previous section, we have a few choices that can be made with regards to how we determine the numerical flux. Upon introduction of a ghost-point and the use of a central boundary flux, we take","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\nsigma^* = fracsigma^- + sigma^+2\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Enforcing the boundary condition sigma^*(-1) = sigma_L or sigma^*(1) = sigma_R means that, with the reflection principle, we use ghost points","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    sigma^+(-1) = - sigma_0 + 2 sigma_L\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"and similarly for the right endpoint. As we have done with the advection example, we can philosophize about what it means to be on the boundary and take sigma^+(-1)  = sigma_L and sigma^+(1) = sigma_R and take","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    sigma^*(1) = (sigma_N + sigma_R)2\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"(similarly for the left endpoint). Or we could be more flexible and interpolate between the two with the introduction of the parameter alpha, to get","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    sigma^+ = - alpha sigma^- +  (1+alpha)sigma^textbc\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"We could enforce the different endpoints differently and make one choice on one boundary and a different choice on the other.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Let us go through the budget argument and the energy argument just as before. For simplicity we will choose sigma_L = sigma_R = 0. In the budget argument, choosing alpha = 1, aka, making the flux on the boundary the flux we know that it should be yields a discrete scheme with exactly the same conservation property. To see this, first note that the discrete budget for rho is","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    partial_t int_E rho = sigma^*(1) - sigma^*(-1) = (1-alpha_-1)fracsigma_N2 - (1-alpha_+1)fracsigma_02\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"For the PDE this is","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\npartial_t int_E rho = sigma(1) - sigma(-1) = 0\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"We can also look towards the energy argument for some guidance. In the PDE we get","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    partial_t int_E rho^2 = - int_E sigma^2 + rho(1) sigma(1) - rho(-1) sigma(-1) \n    = - int_E sigma^2 + 0\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The discrete equations are","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    frac12 partial_t rho_i mathcalM_ij rho_j = - rho_i mathcalS_ji sigma_j + rho_N sigma^*(1) - rho_0 sigma^*(-1) \n    sigma_i mathcalM_ij sigma_j = - sigma_i mathcalS_ji rho_j + sigma_N rho^*(1) - sigma_0 rho^*(-1)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"We use the discrete integration by parts formula,","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\nrho_i mathcalS_ji sigma_j = sigma_i mathcalS_ij rho_j =  sigma_i (mathcalS_ij +mathcalS_ji - mathcalS_ji ) rho_j  = rho_N sigma_N - rho_0 sigma_0 - sigma_i mathcalS_ji rho_j\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"to place everything in one equation. (We used the algebraic property of mathcalS_ij+mathcalS_ji in the derivation.) The second equation, becomes","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n- rho_i mathcalS_ji sigma_j =\n- sigma_i mathcalM_ij sigma_j  + sigma_N (rho^*(1) - rho_N) - sigma_0 (rho^*(-1) - rho_N)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Thus in the discrete equation we have","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    frac12 partial_t rho_i mathcalM_ij rho_j = -sigma_i mathcalM_ij sigma_j + sigma_N (rho^*(1) - rho_N) - sigma_0 (rho^*(-1) - rho_N)\n    \n    + rho_N sigma^*(1) - rho_0 sigma^*(-1)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"In this case we see that rho^* = rho^-, i.e., rho^*(1t) = rho_N and rho^*(-1t) = rho_0 as well as sigma^* = 0 yields a structure that is algebraically similar to the PDE. Thus in the case of the diffusion equation we see that there seems to be a ``best\" choice of boundary fluxes.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"For Dirichlet boundary conditions much is the same. Here the roles of sigma and rho switch places, and we \"impose\" transmissive flux conditions for sigma and the different variations of boundary conditions for rho. The balance budget and energy will mimic the behavior of the PDE if we choose rho^* = rho^textbc.","category":"page"},{"location":"boundary_conditions/#Boundary-Conditions-for-the-Advection-Diffusion-Equation","page":"Boundary Conditions","title":"Boundary Conditions for the Advection-Diffusion Equation","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The PDE is","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    partial_t rho + partial_x (u rho) = partial_x sigma \n    sigma = partial_x rho\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"and the discrete form is","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    partial_t mathcalM_ij rho_j - mathcalS_ji (u rho_j) =\n    - mathcalS_ji sigma_j\n    + delta_iN sigma^*(1)\n    - delta_i0 sigma^*(-1)\n    \n    text  - delta_iN (u rho)^*(1)\n    +\n    delta_i0 (u rho)^*(-1)\n    \n    mathcalM_ij sigma_j = -  mathcalS_jirho_j\n    + delta_iN rho^*(1)\n    -\n    delta_i0 rho^*(-1)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Before discussing boundary conditions let us look at the budgets and energy argument. Integrating the PDE over the domain yields","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    partial_t int_E rho\n    = -u rho(1) + u rho(-1) +  sigma(1) - sigma(-1)\n    \n    int_E sigma = rho(1) - rho(-1)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The discrete budget is","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    partial_t int_E rho\n    = -(u rho)^*(1) + (u rho)^*(-1) +  sigma^*(1) - sigma^*(-1)\n    \n    int_E sigma = rho^*(1) - rho^*(-1)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The energy argument (multiplying through by rho, integrating over the domain, and performing sufficient integration by parts) for the PDE yields","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    frac12 partial_t rho^2 = - int_E sigma^2 - fracu2left( rho(1)^2 - rho(-1)^2  right)\n    + rho(1) sigma(1) - rho(-1) sigma(-1)\n    \n    int_E sigma^2 = int_E sigma partial_x rho\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The discrete energy argument yields","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    frac12 partial_t rho_i mathcalM_ij rho_j = - sigma_i mathcalM_ij sigma_j\n    \n    + rho_N left(fracu2rho_N - (u rho)^*(1) right) - rho_0 left(fracu2 rho_0   - (u rho)^*(-1) right)\n    \n    + rho_N sigma^*(1) - rho_0 sigma^*(-1)\n    \n    + sigma_N ( rho^*(1) - rho_N) - sigma_0 left( rho^*(-1) - rho_0 right)\n    \n    sigma_i mathcalM_ij sigma_j = - sigma_i mathcalS_ji rho_j     + sigma_N rho^*(1)\n    -\n    sigma_0 rho^*(-1)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Now let us talk about Dirichlet boundary conditions on this system, and specifically rho(1) = rho(-1) = 0. Comparing the equations, we see that to mimic the algebraic structure of the budget, we must choose (urho)^* = rho^* = 0 and sigma^* = sigma^-. This is because the PDE budget is","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    partial_t int_E rho\n    = -0 + 0 +  sigma(1) - sigma(-1)\n    \n    int_E sigma = 0 - 0\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"and each term in the discrete budget must be zero where the PDE budget is zero. The only terms that are non-zero are the sigma terms, which are free to be whatever they want to be since they don't have any boundary conditions.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"However, comparing the PDE energy becomes","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    frac12 partial_t rho^2 = - int_E sigma^2\n    \n    int_E sigma^2 = int_E sigma partial_x rho = - int_E (partial_x sigma) rho\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"thus we must choose,","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n(urho)^* = fracu rho^- + 02 text   rho^* = 0 text and  sigma^* = sigma^-\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"In the advective flux case where are taking a central flux between what we see in the interior to the domain and what we see exterior, whereas in the terms associated with the diffusive flux we are simply setting the value of rho^* to what it should be on the boundary. We remind the reader that (urho)^* = fracu rho^- + 02 is an abbreviation for the simultaneous prescription (urho)^*(1) = u rho_N2 and (urho)^*(-1) = u rho_0 2. In order to algebraically replicate the energy budget of the PDE. One point in favor of the energy argument is that it leads to a  numerically stable algorithm whereas in the budget case one has to hope that the dissipation is enough to make things not get too out of control.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Homogeneous Neumann boundary conditions for the present problem does not make too much sense, since one is just shoving material against the right wall and not letting it escape.","category":"page"},{"location":"boundary_conditions/#Brief-Discussion-on-Robin-Boundary-Conditions-/-Relaxation-Boundary-Conditions","page":"Boundary Conditions","title":"Brief Discussion on Robin Boundary Conditions / Relaxation Boundary Conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Robin boundary conditions are boundary conditions of the form","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    alpha rho(1) + beta sigma(1) = lambda\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"or similarly for the left endpoint. This kind of boundary condition comes up in the CLIMA Ocean code, when one has a relaxation to a surface temperature. In that context the boundary condition is","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n   left kappa partial_z T right_textsurface = lambda left( left T right_textsurface - T_0 right)\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"where T_0 is some prescribed temperature field.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The difficulty in enforcing this kind of boundary condition through numerical fluxes comes from interpreting what is \"transmissive\" and what isn't. In the particular cases of Dirichlet or Neumann boundary conditions, it was clear that the variable without boundary conditions is the one that needs transmissive fluxes; however here the boundary condition is a linear combination of Dirichlet and Neumann.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Let us focus on potential ways to enforce this boundary condition. One way is to interpret the equation as meaning","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    alpha rho^*(1) + beta sigma^*(1) = lambda\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Given that robin boundary conditions involve a linear combination of rho and sigma, this is suggestive of making the transmissive flux a linear combination of rho and sigma as well. Thus, we will explore options of the form","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\nbeginbmatrix\nalpha  beta \nc  d\nendbmatrix\nbeginbmatrix\nrho^* \nsigma^*\nendbmatrix\n=\nbeginbmatrix\nlambda \nc rho^- + d sigma^-\nendbmatrix\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"where alpha d - beta c neq 0. We just added an auxiliary linear equation to \"enforce\" transmissive boundary conditions. The choice c=1, d = 0, leads to","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    rho^* = rho^- \n    sigma^* = fraclambdaalpha - fracbetaalpha rho^-\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"This is similar to how these boundary conditions are enforced in finite volume codes where one adds a relaxation term to the appropriate grid cell. The choice c = 0, d = 1, leads to","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n    rho^* = fraclambdabeta - fracbetaalpha sigma^- \n    sigma^* = sigma^-\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"and the choice c = -beta and d = alpha leads to","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"beginaligned\n(alpha^2 + beta^2) rho^* = alpha lambda + beta^2 rho^- - beta alpha sigma^- \n(alpha^2 + beta^2) sigma^* = beta lambda - alpha beta rho^- + alpha^2 sigma^-\nendaligned","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"which reduced to Dirichlet boundary conditions when alpha neq 0 beta = 0 and Neumann boundary conditions when alpha = 0 beta neq 0.","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"At this point it is unclear which of these choices works best, or if they all lead to the same results. Certainly one can generalize by including ghost-points. At any rate it is documented here for future reference and to open up discussion.","category":"page"},{"location":"#DG_Playground","page":"Home","title":"DG_Playground","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A repository for quickly prototyping ideas ideas for the CLIMA project. The main objectives are to","category":"page"},{"location":"","page":"Home","title":"Home","text":"Test / develop relevant preconditioners\nCreate useful abstractions for timestepping and DG operators","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core DG algorithm being used here is based on the textbook by Hesthaven and Warburton.","category":"page"}]
}
